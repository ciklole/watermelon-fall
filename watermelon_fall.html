<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>Watermelon Catch</title>
	<style>
		html,body{height:100%;width:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;overflow:hidden;background:#000}
		@keyframes comboPulse{0%{transform:translateX(-50%) scale(0.8);opacity:0}50%{transform:translateX(-50%) scale(1.2)}100%{transform:translateX(-50%) scale(1);opacity:1}}
		@keyframes shimmer{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
		.wrap{position:fixed;top:0;left:0;width:100vw;height:100vh;padding:0;margin:0;display:block}
		h1{display:none}
		canvas{position:absolute;top:0;left:0;width:100%;height:100%;display:block;background:linear-gradient(#87CEEB,#a6f0ff)}
		.ui{position:fixed;left:-380px;top:0;width:360px;height:100vh;background:rgba(255,255,255,0.95);padding:10px;border-radius:0;z-index:100;overflow-y:auto;transition:left 0.3s ease;box-shadow:2px 0 10px rgba(0,0,0,0.2)}
		.ui.open{left:0}
		.ui-toggle{position:fixed;left:10px;top:10px;z-index:101;background:rgba(255,255,255,0.9);border:none;width:40px;height:40px;border-radius:8px;cursor:pointer;font-size:18px;transition:all 0.3s}
		.ui-toggle:hover{background:rgba(255,255,255,1);transform:scale(1.1)}
		.ui h2{margin-top:0;font-size:18px}
		.panel{background:rgba(220,220,220,0.8);padding:8px 12px;border-radius:8px;margin-bottom:8px;font-size:14px}
		.panel strong{font-size:16px}
		button{padding:8px 10px;border-radius:6px;border:1px solid #ccc;background:white;cursor:pointer;transition:all 0.2s}
		button:hover{background:#f0f0f0;transform:scale(1.05)}
		button:active{transform:translateY(1px)}
		#menu{position:fixed;top:0;left:0;width:100%;height:100%;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);display:flex;align-items:center;justify-content:center;z-index:200;flex-direction:column;gap:20px}
		#menu.hidden{display:none}
		#menu h1{display:block;color:white;font-size:48px;margin:0;text-shadow:2px 2px 4px rgba(0,0,0,0.3)}
		#menu p{color:white;font-size:18px;text-align:center;max-width:500px}
		#menu button{padding:15px 40px;font-size:18px;margin:10px;background:white;color:#667eea;font-weight:bold;border:none}
		#menu button:hover{background:#f0f0f0}
		#shop{display:none;position:fixed;right:20px;top:20px;width:320px;background:rgba(255,255,255,.98);padding:12px;border-radius:8px;box-shadow:0 6px 24px rgba(0,0,0,.2);z-index:101;max-height:80vh;overflow-y:auto}
		#shop h3{margin:6px 0}
		.upgrade{display:flex;justify-content:space-between;align-items:center;padding:6px 0;border-bottom:1px dashed #eee;font-size:12px}
		.small{font-size:13px;color:#666}
		#msg{position:fixed;left:50%;transform:translateX(-50%);top:12px;background:rgba(0,0,0,.7);color:white;padding:6px 12px;border-radius:20px;display:none;z-index:102;font-size:14px}
		.speed-display{position:fixed;right:15px;top:15px;background:rgba(255,255,255,0.9);padding:8px 12px;border-radius:8px;font-weight:bold;z-index:99}
		.combo-display{position:fixed;left:50%;transform:translateX(-50%);top:60px;font-size:44px;font-weight:900;color:#FFD700;text-shadow:0 0 15px rgba(255,215,0,0.9),0 0 30px rgba(255,100,0,0.7),0 0 45px rgba(255,0,0,0.3);pointer-events:none;letter-spacing:3px;opacity:0;z-index:99;display:block}
		.combo-display.active{opacity:1;animation:comboPulse 0.4s ease-out}
		.life-lost{position:fixed;left:50%;transform:translateX(-50%);top:120px;font-size:48px;font-weight:900;color:#FF6B6B;text-shadow:0 0 20px rgba(255,107,107,1),0 0 40px rgba(255,0,0,0.8);pointer-events:none;letter-spacing:2px;opacity:0;z-index:99;animation:lifeLostPulse 0.6s ease-out}
		@keyframes lifeLostPulse{0%{opacity:1;transform:translateX(-50%) scale(0.5)}50%{opacity:1;transform:translateX(-50%) scale(1.1)}100%{opacity:0;transform:translateX(-50%) scale(1)}}
		#minigame{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);width:auto;height:auto;background:linear-gradient(135deg,#FFD700 0%,#FFA500 100%);display:none;align-items:center;justify-content:center;z-index:150;flex-direction:column;gap:20px;padding:30px;border-radius:16px;box-shadow:0 8px 32px rgba(0,0,0,0.3)}
		#minigame.active{display:flex}
		#minigame h1{display:block;color:white;font-size:36px;margin:0;text-shadow:2px 2px 4px rgba(0,0,0,0.3)}
		#minigame p{color:white;font-size:16px;text-align:center;max-width:400px;margin:0}
		.minigame-stats{background:rgba(255,255,255,0.95);padding:20px;border-radius:12px;font-size:20px;font-weight:bold;text-align:center;min-width:250px}
		.minigame-stats div{margin:8px 0}
		#minigameTimer{font-size:32px;color:#FF6B6B}
		.secret-btn{position:fixed;background:transparent;border:none;padding:4px 8px;cursor:pointer;z-index:50;font-size:10px;opacity:0.1;transition:all 0.3s;color:rgba(100,149,237,0.15)}
		.secret-btn:hover{opacity:1;background:rgba(255,255,0,0.3);border-radius:4px;color:#667eea}
	</style>
</head>
<body>
	<div id="menu">
		<h1>üçâ Watermelon Catch üçâ</h1>
		<p>Catch the falling watermelons! Use the mouse or arrow keys.</p>
		<button id="startBtn">Start Game</button>
		<p style="font-size:12px;opacity:0.7">üîë Hint: Press 'G' during the game for a surprise!</p>
	</div>
	<div id="minigame">
		<h1>üí∞ GOLDEN RUSH üí∞</h1>
		<p>Catch ONLY golden watermelons for bonus coins!</p>
		<div class="minigame-stats">
			<div>Time: <span id="minigameTimer">30</span>s</div>
			<div>Golden Caught: <span id="minigameCaught">0</span></div>
			<div>Bonus Coins: <span id="minigameCoins">0</span></div>
		</div>
	</div>
	<button class="secret-btn" id="secretBtn" title="...">¬∑</button>
	<button class="ui-toggle" id="uiToggle">‚ò∞</button>
	<div class="speed-display">Speed: <span id="speedValue">1.0x</span></div>
	<div class="combo-display" id="comboDisplay"></div>
	<div class="life-lost" id="lifeLost">‚ùå LIFE LOST</div>
	<div class="wrap">
		<h1>Watermelon Catch</h1>
		<div class="ui" id="uiPanel">
			<h2>Stats</h2>
			<div class="panel">Score: <strong id="score">0</strong></div>
			<div class="panel">Coins: <strong id="coins">0</strong></div>
			<div class="panel">Wave: <strong id="wave">1</strong></div>
			<div class="panel">Lives: <strong id="lives">3</strong>‚ù§Ô∏è</div>
			<hr>
			<h2>Controls</h2>
			<div class="small" style="margin-bottom:10px">üñ±Ô∏è Mouse to move basket<br>‚¨ÖÔ∏è ‚û°Ô∏è Arrow keys</div>
			<button id="shopBtn" style="width:100%;margin-bottom:8px">Shop & Upgrades</button>
			<button id="restartBtn" style="width:100%;margin-bottom:8px">Restart Game</button>
			<button id="menuBtn" style="width:100%">Back to Menu</button>
		</div>
		<canvas id="game"></canvas>
	</div>

	<div id="shop">
		<h3>Shop & Upgrades</h3>
		<div id="upgradesList"></div>
		<div style="margin-top:10px;text-align:right"><button id="closeShop">Close</button></div>
	</div>
	<div id="msg"></div>

	<script>
	(function(){
		const canvas = document.getElementById('game');
		const ctx = canvas.getContext('2d');
		const scoreEl = document.getElementById('score');
		const coinsEl = document.getElementById('coins');
		const waveEl = document.getElementById('wave');
		const livesEl = document.getElementById('lives');
		const lifeLostDisplay = document.getElementById('lifeLost');
		const uiPanel = document.getElementById('uiPanel');
		const uiToggle = document.getElementById('uiToggle');
		const menu = document.getElementById('menu');
		const startBtn = document.getElementById('startBtn');
		const restartBtn = document.getElementById('restartBtn');
		const menuBtn = document.getElementById('menuBtn');
		const shopBtn = document.getElementById('shopBtn');
		const shop = document.getElementById('shop');
		const closeShop = document.getElementById('closeShop');
		const upgradesList = document.getElementById('upgradesList');
		const msg = document.getElementById('msg');
		const comboDisplay = document.getElementById('comboDisplay');
		const speedValue = document.getElementById('speedValue');
		const minigame = document.getElementById('minigame');
		const secretBtn = document.getElementById('secretBtn');
		const minigameTimer = document.getElementById('minigameTimer');
		const minigameCaught = document.getElementById('minigameCaught');
		const minigameCoins = document.getElementById('minigameCoins');

		// Menu controls
		function showMenu(){ menu.classList.remove('hidden'); state.running = false; }
		function hideMenu(){ menu.classList.add('hidden'); state.running = true; randomizeSecretButton(); }
		startBtn.onclick = ()=>{ resetGame(); hideMenu(); };
		menuBtn.onclick = ()=>{ showMenu(); };
		restartBtn.onclick = ()=>{ if(confirm('Restart game?')) { resetGame(); hideMenu(); } };
		
		// Secret mini-game controls
		function randomizeSecretButton(){
			const positions = [
				{top: '5%', left: '5%', right: 'auto', bottom: 'auto'},
				{top: '5%', left: 'auto', right: '5%', bottom: 'auto'},
				{top: 'auto', left: '5%', right: 'auto', bottom: '5%'},
				{top: 'auto', left: 'auto', right: '5%', bottom: '5%'},
				{top: '15%', left: '10%', right: 'auto', bottom: 'auto'},
				{top: '50%', left: '2%', right: 'auto', bottom: 'auto', transform: 'translateY(-50%)'},
				{top: 'auto', left: 'auto', right: '2%', bottom: '50%', transform: 'translateY(50%)'},
				{top: '80%', left: '5%', right: 'auto', bottom: 'auto'},
				{top: '20%', left: 'auto', right: '3%', bottom: 'auto'},
				{top: 'auto', left: '50%', right: 'auto', bottom: '3%', transform: 'translateX(-50%)'},
			];
			const pos = positions[Math.floor(Math.random() * positions.length)];
			Object.assign(secretBtn.style, pos);
		}
		
		function startMiniGame(){
			if(!state.running || state.inMiniGame) return;
			state.inMiniGame = true;
			state.miniGameTime = 30;
			state.miniGameCaught = 0;
			state.miniGameCoins = 0;
			minigame.classList.add('active');
			secretBtn.textContent = '¬∑';
			secretBtn.disabled = true;
		}
		
		function endMiniGame(){
			state.inMiniGame = false;
			state.coins += state.miniGameCoins;
			minigame.classList.remove('active');
			secretBtn.textContent = '¬∑';
			secretBtn.disabled = false;
			randomizeSecretButton();
			showMsg(`Golden Rush Complete! +${state.miniGameCoins} bonus coins!`);
			save();
		}
		
		secretBtn.onclick = startMiniGame;
		window.addEventListener('keydown', e=>{
			if((e.key === 'g' || e.key === 'G') && state.running && !state.inMiniGame) startMiniGame();
		});
		
		// UI toggle
		uiToggle.onclick = ()=>{ uiPanel.classList.toggle('open'); };

		// Calculate fullscreen canvas dimensions
		function getCanvasDimensions(){
			return { w: window.innerWidth, h: window.innerHeight };
		}

		function resizeCanvas(){
			const dims = getCanvasDimensions();
			canvas.width = dims.w;
			canvas.height = dims.h;
		}

		resizeCanvas();
		let W = canvas.width, H = canvas.height;

		window.addEventListener('resize', ()=>{
			resizeCanvas();
			W = canvas.width;
			H = canvas.height;
			state.basket.scaleToCanvas();
		});

		class Basket{
			constructor(){
				this.baseW = 120;
				this.w = this.baseW;
				this.h = 28;
				this.x = W/2 - this.w/2;
				this.y = H - 40;
				this.speed = 8;
				this.catchFlash = 0;
			}
			scaleToCanvas(){
				this.w = (W / 720) * this.baseW;
				this.h = (H / 540) * 28;
				this.y = H - (40 * H / 540);
				this.speed = 8 * (W / 720);
			}
			draw(){
				// Flash animation on catch
				const flashAlpha = Math.max(0, this.catchFlash);
				this.catchFlash = Math.max(0, this.catchFlash - 0.1);
				
				// Main basket body
				ctx.fillStyle='#6b3'; 
				ctx.fillRect(this.x,this.y,this.w,this.h); 
				ctx.fillStyle='#442'; 
				ctx.fillRect(this.x+6,this.y-6,this.w-12,6);
				
				// Glow effect
				ctx.shadowColor = `rgba(107, 187, 51, ${0.5 + flashAlpha * 0.5})`;
				ctx.shadowBlur = 15 + flashAlpha * 20;
				ctx.shadowOffsetX = 0;
				ctx.shadowOffsetY = 0;
				ctx.strokeStyle = '#4a8a2a';
				ctx.lineWidth = 2;
				ctx.strokeRect(this.x,this.y,this.w,this.h);
				
				// Flash effect
				if(flashAlpha > 0){
					ctx.fillStyle = `rgba(255, 255, 255, ${flashAlpha * 0.5})`;
					ctx.fillRect(this.x,this.y,this.w,this.h);
				}
				
				ctx.shadowBlur = 0;
			}
			moveTo(x){ this.x = Math.max(6, Math.min(W-this.w-6, x - this.w/2)); }
			step(dir){ this.x = Math.max(6, Math.min(W-this.w-6, this.x + dir*this.speed)); }
		}

		class Watermelon{
			constructor(x,y,vy,type='normal'){
				this.x=x;this.y=y;this.vy=vy;this.type=type;this.r=type==='small'?14:22;this.caught=false;
				this.baseR = this.r;
				this.rotation = 0;
				this.rotationSpeed = Math.random() * 6 + 3;
				this.trail = [];
				this._setProps();
			}
			_setProps(){
				const t=this.type;
				const scale = W / 720;
				if(t==='fast'){this.color='#ff6b6b';this.points=15;this.vy*=1.6;this.rotationSpeed*=1.5}
				else if(t==='gold'){this.color='#ffd86b';this.points=50; this.r=26*scale}
				else if(t==='heavy'){this.color='#9ae6b4';this.points=25; this.vy*=0.8; this.r=28*scale;this.rotationSpeed*=0.6}
				else {this.color='#4caf50';this.points=10}
				if(t !== 'gold' && t !== 'heavy') this.r = this.baseR * scale;
			}
			update(dt, effects){
				this.y += this.vy * dt * (effects.slow ? 0.6 : 1) * state.gameSpeed;
				this.rotation += this.rotationSpeed * dt;
				this.trail.push({x: this.x, y: this.y, life: 0.5});
				this.trail = this.trail.filter(p => p.life > 0);
				this.trail.forEach(p => p.life -= dt);
				if(effects.magnet){ /* pull towards basket center handled in game loop */ }
			}
			draw(){ 
				ctx.save();
				// Draw trail
				this.trail.forEach((p, i) => {
					ctx.globalAlpha = (p.life / 0.5) * 0.3;
					ctx.fillStyle = this.color;
					ctx.beginPath();
					ctx.arc(p.x, p.y, this.r * 0.6, 0, Math.PI * 2);
					ctx.fill();
				});
				ctx.globalAlpha = 1;
				ctx.translate(this.x, this.y);
				ctx.rotate(this.rotation);
				ctx.beginPath(); 
				ctx.fillStyle=this.color; 
				ctx.ellipse(0,0,this.r,this.r*0.86,0,0,Math.PI*2); 
				ctx.fill();
				ctx.fillStyle='#2c7'; 
				ctx.fillRect(-4,-3,8,3);
				ctx.fillStyle='rgba(255,255,255,0.4)';
				ctx.beginPath();
				ctx.ellipse(-this.r*0.3, -this.r*0.3, this.r*0.3, this.r*0.2, 0, 0, Math.PI*2);
				ctx.fill();
				ctx.restore();
			}
		}
		
		class Particle{
			constructor(x, y, vx, vy, life, color, size){
				this.x = x; this.y = y; this.vx = vx; this.vy = vy;
				this.life = life; this.maxLife = life;
				this.color = color; this.size = size;
			}
			update(dt){
				this.x += this.vx * dt;
				this.y += this.vy * dt;
				this.vy += 200 * dt;
				this.life -= dt;
			}
			draw(){
				const alpha = this.life / this.maxLife;
				ctx.globalAlpha = alpha;
				ctx.fillStyle = this.color;
				ctx.beginPath();
				ctx.arc(this.x, this.y, this.size * (1 - (1 - alpha)), 0, Math.PI * 2);
				ctx.fill();
			}
		}

		const state = {
			basket: new Basket(),
			watermelons: [],
			particles: [],
			score: 0,
			coins: 0,
			wave: 1,
			lives: 3,
			maxLives: 3,
			spawnTimer:0,
			spawnInterval:1.0,
			running:false,
			gameSpeed: 1.0,
			inMiniGame: false,
			miniGameTime: 0,
			miniGameCaught: 0,
			miniGameCoins: 0,
			screenShake: 0,
			effects:{ slow:false, magnet:false, double:false },
			upgrades:[],
		};
		state.basket.scaleToCanvas();

		const saved = JSON.parse(localStorage.getItem('wm_state')||'{}');
		state.coins = saved.coins||0; state.score = saved.score||0; state.upgrades = saved.upgrades||[];

		const baseTypes = ['normal','fast','gold','heavy'];

		const upgrades = [
			{id:'basket_size',name:'Wider Basket',desc:'Increase basket width',cost:50,level: saved.upgrades?.basket_size||0, max:5, apply(level){ state.basket.baseW = 120 + level*20; state.basket.scaleToCanvas(); }},
			{id:'basket_speed',name:'Basket Speed',desc:'Move faster',cost:80,level: saved.upgrades?.basket_speed||0, max:5, apply(level){ state.basket.speed = (8 + level*2) * (W/720); }},
			{id:'slow',name:'Slow Fall',desc:'Slow watermelons down',cost:100,level: saved.upgrades?.slow||0, max:3, apply(level){ state.effects.slow = level>0 }},
			{id:'magnet',name:'Magnet Field',desc:'Attract watermelons',cost:150,level: saved.upgrades?.magnet||0, max:3, apply(level){ state.effects.magnet = level>0 }},
			{id:'spawn_rate',name:'Spawn Rate',desc:'More watermelons',cost:180,level: saved.upgrades?.spawn_rate||0, max:5, apply(level){ state.spawnRateMultiplier = Math.max(0.35, 1 - 0.14*level) }},
			{id:'double',name:'Double Points',desc:'2x points earned',cost:300,level: saved.upgrades?.double||0, max:1, apply(level){ state.effects.double = level>0 }},
			{id:'game_speed',name:'Speed Boost',desc:'Game runs faster',cost:120,level: saved.upgrades?.game_speed||0, max:5, apply(level){ state.gameSpeed = 1.0 + level*0.2; }},
			{id:'coin_multiplier',name:'Coin Riches',desc:'Earn more coins',cost:200,level: saved.upgrades?.coin_multiplier||0, max:4, apply(level){ state.coinMultiplier = 1.0 + level*0.25; }},
			{id:'combo',name:'Combo Streak',desc:'Bonus for catches',cost:250,level: saved.upgrades?.combo||0, max:3, apply(level){ state.comboEnabled = level>0; state.comboMultiplier = level; }},
		];

		function save(){
			localStorage.setItem('wm_state', JSON.stringify({coins:state.coins,score:state.score,upgrades: Object.fromEntries(upgrades.map(u=>[u.id,u.level]))}));
		}

		function spawnWatermelon(){
			const x = (W * 20/720) + Math.random() * (W - (40 * W/720));
			const baseVy = 80 + state.wave*10 + Math.random()*40;
			let type='normal';
			
			if(state.inMiniGame){
				type = 'gold';
			} else {
				const r = Math.random();
				if(r>0.985) type='gold';
				else if(r>0.9) type='fast';
				else if(r>0.8) type='heavy';
			}
			const w = new Watermelon(x,-30, baseVy, type);
			state.watermelons.push(w);
		}

		let last = performance.now();
		function loop(now){
			const dt = (now-last)/1000; last=now;
			update(dt);
			draw();
			requestAnimationFrame(loop);
		}

		function update(dt){
			if(!state.running) return;
			
			// Update screen shake
			state.screenShake = Math.max(0, state.screenShake - dt);
			
			// Update particles
			for(let i = state.particles.length - 1; i >= 0; i--){
				state.particles[i].update(dt);
				if(state.particles[i].life <= 0){
					state.particles.splice(i, 1);
				}
			}
			
			// Mini-game timer
			if(state.inMiniGame){
				state.miniGameTime -= dt;
				minigameTimer.textContent = Math.max(0, Math.ceil(state.miniGameTime));
				if(state.miniGameTime <= 0){
					endMiniGame();
					return;
				}
			}
			
			state.spawnTimer -= dt;
			const effectiveInterval = (state.spawnInterval || 0.9) * (state.spawnRateMultiplier || 1);
			const spawnRate = state.inMiniGame ? effectiveInterval * 0.5 : effectiveInterval;
			if(state.spawnTimer <=0){ spawnWatermelon(); state.spawnTimer = spawnRate; }
			// effects from upgrades
			upgrades.forEach(u=>u.apply && u.apply(u.level));

			// update watermelons
			for(let i=state.watermelons.length-1;i>=0;i--){
				const w = state.watermelons[i];
				if(state.effects.magnet){ const bx = state.basket.x + state.basket.w/2; const dx = bx - w.x; w.x += dx*0.06; }
				w.update(dt, state.effects);
				if(w.y - w.r > H){ // missed
					// Create explosion effect for missed watermelon
					createExplosion(w.x, H, '#ff0000', 12);
					comboCatch = 0;
					state.screenShake = 0.4;
					state.lives--;
					// Trigger life lost animation
					lifeLostDisplay.style.animation = 'none';
					setTimeout(() => lifeLostDisplay.style.animation = 'lifeLostPulse 0.6s ease-out', 10);
					if(state.lives <= 0){
						state.running = false;
						showMsg('GAME OVER!');
						showMenu();
					}
					state.watermelons.splice(i,1);
				} else if(collide(w, state.basket)){
					catchWM(w);
					state.watermelons.splice(i,1);
				}
			}
			// slowly increase difficulty
			if(Math.random() < 0.002) state.wave += 1;
			// update UI
			scoreEl.textContent = state.score;
			coinsEl.textContent = state.coins;
			waveEl.textContent = state.wave;
			livesEl.textContent = state.lives;
			speedValue.textContent = state.gameSpeed.toFixed(1) + 'x';
		}

		let comboCatch = 0;
		function catchWM(w){
			state.basket.catchFlash = 1;
			if(state.inMiniGame){
				if(w.type === 'gold'){
					state.miniGameCaught++;
					const bonus = Math.floor(100 * (1 + state.miniGameCaught * 0.05));
					state.miniGameCoins += bonus;
					minigameCaught.textContent = state.miniGameCaught;
					minigameCoins.textContent = state.miniGameCoins;
					showMsg(`+${bonus} coins!`);
					createCatchExplosion(state.basket.x + state.basket.w/2, state.basket.y, '#ffd86b', 12);
				} else {
					showMsg('-10 penalty (wrong type!)');
					state.miniGameCoins = Math.max(0, state.miniGameCoins - 10);
					minigameCoins.textContent = state.miniGameCoins;
					createExplosion(state.basket.x + state.basket.w/2, state.basket.y, '#ff6b6b', 5);
				}
			} else {
				let pts = state.effects.double ? w.points*2 : w.points;
				if(state.comboEnabled) {
					comboCatch++;
					pts = Math.floor(pts * (1 + comboCatch * 0.1));
				}
				state.score += pts;
				const coins = Math.floor(pts / 1 * (state.coinMultiplier || 1));
				state.coins += coins;
				const msg_text = state.comboEnabled && comboCatch > 1 ? `+${pts} pts (${comboCatch}x!)` : `+${pts} pts`;
				showMsg(msg_text);
				createCatchExplosion(w.x, w.y, w.color, 10);
			}
			save();
		}

		function collide(w,b){
			return w.y + w.r > b.y && w.x > b.x && w.x < b.x + b.w;
		}

		function createExplosion(x, y, color, particleCount){
			for(let i = 0; i < particleCount; i++){
				const angle = (Math.PI * 2 * i) / particleCount;
				const speed = 100 + Math.random() * 100;
				const vx = Math.cos(angle) * speed;
				const vy = Math.sin(angle) * speed - 50;
				const p = new Particle(x, y, vx, vy, 0.8, color, 6);
				state.particles.push(p);
			}
		}

		function createCatchExplosion(x, y, color, particleCount){
			for(let i = 0; i < particleCount; i++){
				const angle = (Math.PI * 2 * i) / particleCount;
				const speed = 150 + Math.random() * 100;
				const vx = Math.cos(angle) * speed;
				const vy = Math.sin(angle) * speed - 100;
				const p = new Particle(x, y, vx, vy, 0.6, color, 5);
				state.particles.push(p);
			}
		}

		function drawBackground(){
			// subtle tiled watermelons for a pretty background
			const scale = W / 720;
			ctx.save();
			ctx.globalAlpha = 0.09;
			for(let y=40*scale;y<H;y+=64*scale){
				for(let x=(y%(128*scale)===0?20*scale:60*scale);x<W;x+=96*scale){
					drawDecorWatermelon(x,y,18*scale,'#2e8b57');
				}
			}
			ctx.restore();
			
			// clouds with animation
			const cloudScale = scale;
			const time = performance.now() * 0.001;
			for(let i=0;i<6;i++){ 
				ctx.fillStyle='rgba(255,255,255,0.6)'; 
				ctx.beginPath(); 
				ctx.ellipse((80+i*110)*cloudScale + Math.sin(time + i) * 10, 60*cloudScale, 40*cloudScale, 20*cloudScale, 0, 0, Math.PI*2); 
				ctx.fill(); 
			}
			
			// Magnet effect visual
			if(state.effects.magnet){
				ctx.save();
				ctx.globalAlpha = 0.15;
				ctx.strokeStyle = '#667eea';
				ctx.lineWidth = 2;
				const bx = state.basket.x + state.basket.w/2;
				const by = state.basket.y;
				for(let i = 0; i < 3; i++){
					const r = 40 + i * 30;
					ctx.beginPath();
					ctx.arc(bx, by, r, 0, Math.PI * 2);
					ctx.stroke();
				}
				ctx.restore();
			}
			
			// Slow effect visual
			if(state.effects.slow){
				ctx.save();
				ctx.globalAlpha = 0.08;
				ctx.fillStyle = '#87CEEB';
				for(let i = 0; i < 5; i++){
					const y = (performance.now() * 0.05 + i * H / 5) % H;
					ctx.fillRect(0, y, W, 20);
				}
				ctx.restore();
			}
		}

		function drawDecorWatermelon(x,y,r,color){
			ctx.beginPath(); ctx.fillStyle = color; ctx.ellipse(x,y,r,r*0.86,0,0,Math.PI*2); ctx.fill();
			ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.fillRect(x-4,y-3,8,3);
		}

		function draw(){
			// Screen shake effect
			const shake = state.screenShake * 5;
			const offsetX = (Math.random() - 0.5) * shake;
			const offsetY = (Math.random() - 0.5) * shake;
			
			ctx.save();
			ctx.translate(offsetX, offsetY);
			
			ctx.clearRect(-offsetX,-offsetY,W,H);
			drawBackground();
			// draw watermelons
			state.watermelons.forEach(w=>w.draw());
			// draw particles
			state.particles.forEach(p=>p.draw());
			// draw basket
			state.basket.draw();
			
			ctx.globalAlpha = 1;
			ctx.restore();
		}

		// input
		canvas.addEventListener('mousemove', e=>{
			const rect = canvas.getBoundingClientRect(); state.basket.moveTo(e.clientX - rect.left);
		});
		let left=false,right=false;
		window.addEventListener('keydown', e=>{ if(e.key==='ArrowLeft') left=true; if(e.key==='ArrowRight') right=true; });
		window.addEventListener('keyup', e=>{ if(e.key==='ArrowLeft') left=false; if(e.key==='ArrowRight') right=false; });
		function keyStep(){ if(left) state.basket.step(-1); if(right) state.basket.step(1); }
		setInterval(keyStep,16);

		// shop UI
		function renderShop(){
			upgradesList.innerHTML='';
			upgrades.forEach(u=>{
				const div = document.createElement('div'); div.className='upgrade';
				const left = document.createElement('div'); left.innerHTML = `<strong>${u.name}</strong><div class="small">${u.desc}</div>`;
				const right = document.createElement('div');
				const cost = u.cost * Math.max(1, Math.pow(1.6, u.level));
				right.innerHTML = `<div style="text-align:right">Level ${u.level}/${u.max}<div class="small">Cost: ${Math.floor(cost)}</div></div>`;
				const buy = document.createElement('button'); buy.textContent='Buy'; buy.style.marginLeft='8px';
				buy.disabled = u.level>=u.max || state.coins < Math.floor(cost);
				buy.onclick = ()=>{ if(state.coins >= Math.floor(cost) && u.level < u.max){ state.coins -= Math.floor(cost); u.level++; if(u.apply) u.apply(u.level); showMsg('Purchased '+u.name); save(); renderShop(); } };
				right.appendChild(buy);
				div.appendChild(left); div.appendChild(right);
				upgradesList.appendChild(div);
			});
		}

		shopBtn.onclick = ()=>{ shop.style.display='block'; renderShop(); };
		closeShop.onclick = ()=>{ shop.style.display='none'; };

		function resetGame(){ 
			state.score=0; 
			state.coins=0; 
			state.wave=1; 
			state.lives=state.maxLives; 
			state.watermelons=[]; 
			state.particles=[]; 
			state.gameSpeed = 1.0;
			comboCatch = 0;
			upgrades.forEach(u=>u.level=0); 
			save(); 
		}

		function showMsg(t){ msg.textContent = t; msg.style.display='block'; clearTimeout(msg._t); msg._t = setTimeout(()=>msg.style.display='none',900); }

		// initialize upgrades levels from saved
		upgrades.forEach(u=>{ u.level = (saved.upgrades && saved.upgrades[u.id])||0; if(u.apply) u.apply(u.level); });

		// start spawn pace
		state.spawnInterval = 0.9;
		state.spawnTimer = 0.5;

		requestAnimationFrame(loop);
		// autosave periodically
		setInterval(save,5000);

		// small performance/tuning: increase spawn rate slowly
		setInterval(()=>{ if(state.running) state.spawnInterval = Math.max(0.35, state.spawnInterval - 0.01); },5000);

	})();
	</script>
</body>
</html>
